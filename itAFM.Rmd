---
title: "itAFM"
output:
  html_document:
    df_print: paged
---

This file has the basic code to run itAFM on any dataset and plot the result learning curve and output best-fitting parameters.

# Load data. This takes student-step roll up from Datashop (or similar type of file). See datashop for details.
```{r}
#clean environment
rm(list=ls())

library(data.table)
df <- fread("data/ds313_student_step_All_Data_933_2016_0405_131437.txt")
```

# Some pre-processing to make data easier to inspect/deal with
```{r}
kcm <- 'KC (LFASearchAICWholeModel1)'
response <- 'First Attempt'
opportunity <- 'Opportunity (LFASearchAICWholeModel1)'
individual <- 'Anon Student Id'
time <- 'First Transaction Time'
prediction <- 'Predicted Error Rate (LFASearchAICWholeModel1)'
  
#keep only columns that we care for
names(df) <- make.names(names(df)) #add the periods instead of spaces
names(df)[which( colnames(df)==make.names(eval(kcm)) )] <- "KC" #replace the KC model name with "KC"
names(df)[which( colnames(df)==make.names(eval(response)) )] <- "response" #replace the first attempt response name with "response"
names(df)[which( colnames(df)==make.names(eval(opportunity)) )] <- "opportunity" #replace the opportunity name with "opportunity"
names(df)[which( colnames(df)==make.names(eval(individual)) )] <- "individual" #replace the individualizing factor name with "individual"
names(df)[which( colnames(df)==make.names(eval(prediction)) )] <- "prediction" #replace the individualizing factor name with "prediction"
names(df)[which( colnames(df)==make.names(eval(time)) )] <- "time"
df$success <- ifelse(df$response=="correct",1,0) #recode response as 0 (incorrect) or 1 (correct

col_to_keep <- c("response","KC","opportunity","individual","success","time","prediction")
df_redux <- df[,.SD,.SDcols=col_to_keep]
```


# Calculate difference in time since first step for each student*KC combination
```{r}
#convert time column into time (conveniently)
df_redux$time<- as.POSIXct(df_redux$time,format="%Y-%m-%d %H:%M:%S")

#order things by student and KC
df_ordered <- df_redux[order(df_redux$individual,df_redux$KC,df_redux$time)]

#add new counter of "opportunity"
setDT(df_ordered)[, rec_opportunity := seq_len(.N), by=rleid(individual,KC)]

#get time for first step in each KC for each student
library(plyr)
df_ordered <- ddply(.data = df_ordered,.variables = .(individual,KC),.fun = mutate,first_oppTime =  time[rec_opportunity==1])

#calculate difference in time from first step
df_ordered$timeDiff <- difftime(df_ordered$time,df_ordered$first_oppTime,units="mins")

```

# Use time instead of step in model similar to iAFM/AFM
```{r}

#convert success to errorRate
df_ordered$errorRate <- 1 - df_ordered$success

library(lme4)
library(optimx)
irafm.model <- suppressWarnings(glmer(errorRate ~ timeDiff + (timeDiff|individual) + (timeDiff|KC), data=df_ordered, family=binomial(),control = glmerControl(optimizer = "optimx", calc.derivs = FALSE,optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))))
```

# Add new predicted performance to dataset
```{r}
df_ordered$prediction <- predict(irafm.model,df_ordered,type="response",allow.new.levels=TRUE)
```

# Graph learning curve (overall)
```{r}
library(ggplot2)
df_ordered <- as.data.table(df_ordered)
df_ordered$time_opp <- round(df_ordered$timeDiff)
sum_df <- df_ordered[,.(actual_errorRate = mean(errorRate),predicted_errorRate = mean(prediction)),by=time_opp]

sum_df_long <- melt(data = sum_df,id.vars = c("time_opp"),measure.vars = c("actual_errorRate","predicted_errorRate"),variable.name = "typeRate",value.name = "ErrorRate")

ggplot(data=sum_df_long, aes(x=time_opp, y=ErrorRate,shape = typeRate,colour = typeRate)) +
  geom_point() + geom_line()
```


# Export best-fitting parameters
```{r}
model_AIC <- AIC(irafm.model)
model_BIC <- BIC(irafm.model)
model_logLik <- as.numeric(logLik(irafm.model))
maineffect_intercept <- fixef(irafm.model)[[1]]
maineffect_slope <- fixef(irafm.model)[[2]]

stud.params <- data.frame(cbind(row.names(ranef(irafm.model)$individual), ranef(irafm.model)$individual[,1], ranef(irafm.model)$individual[,2]) )
stud.params <- cbind(Type="Student", stud.params)
colnames(stud.params) <- c("Type", "Student", "Intercept", "Slope")

stud.params

std_slope_variance <- var((as.numeric(as.character(stud.params$Slope))))
std_intercept_variance <- var((as.numeric(as.character(stud.params$Intercept))))
std_slope_median <- median((as.numeric(as.character(stud.params$Slope))))
std_intercept_median <- median((as.numeric(as.character(stud.params$Intercept))))

cols <- c("std_slope","std_intercept")
rows <- c("median","variance")
stud.parm.var <- matrix(c(std_slope_median,std_intercept_median,std_slope_variance,std_intercept_variance),ncol=2,byrow = TRUE)
colnames(stud.parm.var) <- cols
rownames(stud.parm.var) <- rows

as.data.frame(stud.parm.var)

kc.params <- data.frame(cbind(row.names(ranef(irafm.model)$KC),ranef(irafm.model)$KC[,1], ranef(irafm.model)$KC[,2]) )
kc.params <- cbind(Type="Skill", kc.params)
colnames(kc.params) <- c("Type", "KC", "Intercept", "Slope")

kc.params

kc_slope_variance <- var((as.numeric(as.character(kc.params$Slope))))
kc_intercept_variance <- var((as.numeric(as.character(kc.params$Intercept))))
kc_slope_median <- median((as.numeric(as.character(kc.params$Slope))))
kc_intercept_median <- median((as.numeric(as.character(kc.params$Intercept))))

cols <- c("kc_slope","kc_intercept")
rows <- c("median","variance")
kc.parm.var <- matrix(c(kc_slope_median,kc_intercept_median,kc_slope_variance,kc_intercept_variance),ncol=2,byrow = TRUE)
colnames(kc.parm.var) <- cols
rownames(kc.parm.var) <- rows

as.data.frame(kc.parm.var)
```
